import * as fs from "fs";
import * as path from "path";

// Define the paths
const iconsDir = path.join(__dirname, "../assets/icons");
const componentsDir = path.join(__dirname, "../src");
const indexFilePath = path.join(componentsDir, "index.ts");

// Ensure the components directory exists
if (!fs.existsSync(componentsDir)) {
  fs.mkdirSync(componentsDir);
}

// Function to write individual icon files
const writeIconFile = (iconName: string, pathData: string) => {
  const kebabCaseName = toKebabCase(iconName);
  const componentContent = `// This file is auto-generated by the generate-icons script.
// Do not edit this file directly.

import type React from "react";
import { Icon } from "./_icon-primitive";

export function ${iconName}Icon(props: React.ComponentPropsWithRef<"svg">) {
  return (
    <Icon {...props}>
      <path d="${pathData}" />
    </Icon>
  );
}
`;

  const filePath = path.join(componentsDir, `${kebabCaseName}-icon.tsx`);

  // Check if the file already exists
  if (fs.existsSync(filePath)) {
    const existingContent = fs.readFileSync(filePath, "utf8");
    // Update the file only if the content has changed
    if (existingContent !== componentContent) {
      fs.writeFileSync(filePath, componentContent, "utf8");
    }
  } else {
    // Create the file if it doesn't exist
    fs.writeFileSync(filePath, componentContent, "utf8");
  }
};

// Function to update the index.ts file
const updateIndexFile = (iconNames: string[]) => {
  const exportStatements =
    iconNames
      .map((iconName) => {
        const kebabCaseName = toKebabCase(iconName);
        return `export { ${iconName}Icon } from "./${kebabCaseName}-icon";`;
      })
      .join("\n") + "\n";
  fs.writeFileSync(indexFilePath, exportStatements, "utf8");
};

// Function to convert file name to PascalCase and replace punctuation
const toPascalCase = (str: string) => {
  // Convert PascalCase to kebab-case
  const kebabCase = str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();

  // Convert kebab-case to PascalCase
  return kebabCase
    .replace(/@/g, "At")
    .replace(/#/g, "Hash")
    .replace(/\+/g, "Plus")
    .replace(/_/g, "Underscore")
    .replace(/&/g, "And")
    .replace(/%/g, "Percent")
    .split(/[^a-zA-Z0-9]/) // Split by non-alphanumeric characters
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()) // Capitalize each word
    .join(""); // Join them back together
};

// Function to convert file name to kebab-case
const toKebabCase = (str: string) => {
  return str
    .replace(/([a-z])([A-Z])/g, "$1-$2")
    .replace(/\s+/g, "-")
    .toLowerCase();
};

// Read all SVG files from the icons directory
fs.readdir(iconsDir, (err, files) => {
  if (err) {
    console.error("Error reading icons directory:", err);
    return;
  }

  // Filter and sort SVG files
  const svgFiles = files.filter((file) => file.endsWith(".svg")).sort();

  // Prepare new components
  const iconNames: string[] = [];

  svgFiles.forEach((file) => {
    const iconName = toPascalCase(path.basename(file, ".svg"));
    const kebabCaseName = toKebabCase(iconName);
    const svgPath = path.join(iconsDir, file);
    const svgContent = fs.readFileSync(svgPath, "utf8");
    const pathDataMatch = svgContent.match(/<path[^>]*d="([^"]*)"/);

    if (pathDataMatch) {
      const pathData = pathDataMatch[1];
      writeIconFile(iconName, pathData);
      iconNames.push(iconName);
    } else {
      console.warn(`No path data found in ${file}, skipping.`);
    }
  });

  // Update the index.ts file
  updateIndexFile(iconNames);
});
